<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shannon, Merry Christmas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Arial', sans-serif;
            cursor: pointer;
        }
        #title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #FFD700;
            font-size: 32px;
            letter-spacing: 5px;
            z-index: 100;
            text-shadow: 0 0 10px #FFD700, 0 0 20px rgba(255, 215, 0, 0.5);
        }
        #loading {
            color: gold; 
            font-size: 20px; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            z-index: 3000;
            background: rgba(0, 0, 0, 0.7); 
            padding: 15px 30px; 
            border-radius: 10px;
        }
        #audio-controls {
            position: absolute;
            bottom: 10px;
            left: 10px; 
            right: auto;
            z-index: 200;
        }
        #play-music-btn {
            padding: 10px; 
            background: #FFD700; 
            border: none; 
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="title">Shannon, Merry Christmas and Happy New Year</div>
    <div id="loading">Loading 3D scene and photos...</div> 
    <div id="audio-controls">
        <button id="play-music-btn">ðŸ”‡ Mute</button> 
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script type="module">
        // --- Core Configuration ---
        let camera, scene, renderer;
        let treeParticles, starSprite, treeHitbox;
        let ornaments = []; 
        let activeOrnament = null; 
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(); 
        
        const PARTICLE_COUNT = 8000; 
        const TREE_HEIGHT = 1300;
        const MAX_RADIUS = 480; 
        const ORNAMENT_SIZE = 60;
        const Z_DISTANCE_FROM_CAMERA = 300; // Distance to zoom the photo in front of the camera

        let isTreeForm = true; 
        let originalParticlePositions = []; 
        let originalOrnamentPositions = []; 
        let ornamentTextures = []; 
        
        // --- Rendering Order Constants for Layering ---
        const RENDER_ORDER_BACKGROUND = 0;
        const RENDER_ORDER_PARTICLES = 10;
        const RENDER_ORDER_ORNAMENTS = 20; // Default layer for photos (above particles)
        const RENDER_ORDER_ZOOMED = 100;    // Highest layer for the currently zoomed photo

        // --- Music Control ---
        const audio = new Audio('christmas_music.mp4'); 
        audio.loop = true;

        // --- Asynchronously Load Local Photos ---
        async function loadAllPhotos() {
            const loadedOrnaments = [];
            const loader = new THREE.TextureLoader();
            
            for (let i = 1; i <= 30; i++) { 
                const path = `photos/${i}.jpg`;
                const h = Math.random() * TREE_HEIGHT * 0.8 + (TREE_HEIGHT * 0.1); 
                const angle = Math.random() * Math.PI * 2;
                const radiusAtHeight = (TREE_HEIGHT - h) / TREE_HEIGHT * MAX_RADIUS;
                const r = radiusAtHeight + 20; 
                const pos = { x: r * Math.cos(angle), y: h - TREE_HEIGHT / 2, z: r * Math.sin(angle) };
                try {
                    const texture = await new Promise((resolve, reject) => {
                        loader.load(path, resolve, undefined, reject);
                    });
                    
                    // SpriteMaterial: Disable depth test to prevent sorting issues, rely on renderOrder.
                    const material = new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true,
                        depthTest: false 
                    });
                    loadedOrnaments.push({ material, pos, texture });
                } catch (e) {
                    if (i > 1) break; 
                    const material = new THREE.SpriteMaterial({ color: 0x884400, depthTest: false }); 
                    loadedOrnaments.push({ material, pos, texture: null }); 
                    break;
                }
            }
            return loadedOrnaments;
        }
        

        // --- 1. Initialize 3D Scene ---
        async function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 1000; 
            camera.position.y = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Particle texture creation
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 215, 0, 0.8)');
            gradient.addColorStop(0.4, 'rgba(128, 100, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,64,64);
            const spriteMap = new THREE.CanvasTexture(canvas);

            // --- Create Particle Tree (Points) ---
            const particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = Math.random() * TREE_HEIGHT;
                const angle = Math.random() * Math.PI * 2;
                const radiusAtHeight = (TREE_HEIGHT - h) / TREE_HEIGHT * MAX_RADIUS;
                const r = radiusAtHeight + (Math.random() - 0.5) * 40; 
                const x = r * Math.cos(angle);
                const y = h - TREE_HEIGHT / 2;
                const z = r * Math.sin(angle);
                positions.push(x, y, z);
                originalParticlePositions.push(new THREE.Vector3(x, y, z)); 
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.1 + 0.05, 0.9, Math.random() * 0.4 + 0.5);
                colors.push(color.r, color.g, color.b);
            }
            
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // PointsMaterial: Disable depth test and set render order
            const particleMaterial = new THREE.PointsMaterial({ 
                size: 12, 
                map: spriteMap, 
                blending: THREE.AdditiveBlending, 
                depthTest: false, 
                transparent: true, 
                vertexColors: true 
            });
            treeParticles = new THREE.Points(particleGeometry, particleMaterial);
            treeParticles.renderOrder = RENDER_ORDER_PARTICLES; // Set particle layer
            scene.add(treeParticles); 
            
            // --- Create Invisible Click Capture Cone (Hitbox) ---
            const coneGeo = new THREE.ConeGeometry(MAX_RADIUS + 50, TREE_HEIGHT + 100, 32); 
            const coneMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0, 
                visible: false 
            });
            treeHitbox = new THREE.Mesh(coneGeo, coneMat);
            treeHitbox.position.y = 0; 
            treeHitbox.userData.isHitbox = true; 
            treeHitbox.renderOrder = RENDER_ORDER_BACKGROUND; // Set hitbox layer
            scene.add(treeHitbox);
            
            // Star
            const starGeo = new THREE.SphereGeometry(25, 16, 16);
            starSprite = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xFFD700 }));
            starSprite.position.set(0, TREE_HEIGHT / 2 + 30, 0);
            const starGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap, color: 0xFFD700, transparent: true, blending: THREE.AdditiveBlending, depthTest: false }));
            starGlow.scale.set(400, 400, 1);
            starSprite.add(starGlow);
            starSprite.renderOrder = RENDER_ORDER_PARTICLES; 
            scene.add(starSprite);
            
            // --- Mount Photos (Sprite) ---
            const loadedPhotos = await loadAllPhotos();
            let ornamentIndex = 0;
            for (const { material, pos, texture } of loadedPhotos) {
                const sprite = new THREE.Sprite(material);
                sprite.position.set(pos.x, pos.y, pos.z);
                sprite.scale.set(ORNAMENT_SIZE, ORNAMENT_SIZE, 1); 
                sprite.renderOrder = RENDER_ORDER_ORNAMENTS; // Default ornament layer
                sprite.userData = { 
                    originalPos: sprite.position.clone(), 
                    originalScale: sprite.scale.clone(), 
                    isZoomed: false,
                    index: ornamentIndex 
                };
                treeParticles.add(sprite); 
                ornaments.push(sprite);
                originalOrnamentPositions.push(sprite.position.clone()); 
                ornamentTextures.push(texture); 
                ornamentIndex++;
            }

            document.getElementById("loading").style.display = "none";
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
        }

        // --- 2. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); 
            
            // Particle tree and Hitbox should rotate together
            if (treeParticles && isTreeForm) {
                treeParticles.rotation.y += 0.002;
                treeHitbox.rotation.y += 0.002;
            }
            if (starSprite) starSprite.rotation.y += 0.002;

            const time = Date.now() * 0.005;
            if (treeParticles) {
                treeParticles.material.size = 12 + Math.sin(time) * 3;
            }

            renderer.render(scene, camera);
        }
        
        // --- Particle and Ornament Scatter Function ---
        function scatterParticles() {
            if (!isTreeForm) return;
            isTreeForm = false;
            const positions = treeParticles.geometry.attributes.position.array;
            
            // 1. Scatter Tree Particles (Large range for "Starlight" effect)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                const distance = Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                const targetX = distance * Math.sin(phi) * Math.cos(theta);
                const targetY = distance * Math.sin(phi) * Math.sin(theta);
                const targetZ = distance * Math.cos(phi);

                new TWEEN.Tween({ x: positions[i3], y: positions[i3+1], z: positions[i3+2] })
                    .to({ x: targetX, y: targetY, z: targetZ }, 1500)
                    .easing(TWEEN.Easing.Exponential.Out)
                    .onUpdate(function(obj) {
                        positions[i3] = obj.x;
                        positions[i3+1] = obj.y;
                        positions[i3+2] = obj.z;
                        treeParticles.geometry.attributes.position.needsUpdate = true;
                    })
                    .start();
            }

            // 2. Scatter Ornaments (Constrained range to ensure visibility)
            for(const ornament of ornaments) {
                if(ornament.userData.isZoomed) continue; 

                const CAMERA_Y = 150;
                
                // Keep photos tightly packed and visible
                const SCATTER_RANGE_X = 600; 
                const SCATTER_RANGE_Y = 400; 
                
                // Z-axis: Keep photos in the near foreground (300 to 800) to ensure they overlap the background particles.
                const MIN_Z = 300; 
                const MAX_Z = 800; 

                const targetX = (Math.random() - 0.5) * 2 * SCATTER_RANGE_X; 
                const targetY = CAMERA_Y + (Math.random() - 0.5) * 2 * SCATTER_RANGE_Y;
                const targetZ = MIN_Z + Math.random() * (MAX_Z - MIN_Z);

                new TWEEN.Tween(ornament.position)
                    .to({ x: targetX, y: targetY, z: targetZ }, 1500)
                    .easing(TWEEN.Easing.Exponential.Out)
                    .start();
            }
        }

        // --- Particle and Ornament Restore Function ---
        function restoreParticles() {
            if (isTreeForm) return;
            isTreeForm = true;
            const positions = treeParticles.geometry.attributes.position.array;

            // 1. Restore Tree Particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const targetPos = originalParticlePositions[i];
                
                new TWEEN.Tween({ x: positions[i3], y: positions[i3+1], z: positions[i3+2] })
                    .to(targetPos, 1500)
                    .easing(TWEEN.Easing.Exponential.Out)
                    .onUpdate(function(obj) {
                        positions[i3] = obj.x;
                        positions[i3+1] = obj.y;
                        positions[i3+2] = obj.z;
                        treeParticles.geometry.attributes.position.needsUpdate = true;
                    })
                    .start();
            }

            // 2. Restore Ornaments
            for(let i = 0; i < ornaments.length; i++) {
                const ornament = ornaments[i];
                if(ornament.userData.isZoomed) continue;
                
                // Reset to default render order
                ornament.renderOrder = RENDER_ORDER_ORNAMENTS;

                new TWEEN.Tween(ornament.position)
                    .to(originalOrnamentPositions[i], 1500) 
                    .easing(TWEEN.Easing.Exponential.Out)
                    .start();
            }
        }

        // --- Mouse Click Event ---
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersectableObjects = [...ornaments, treeHitbox];
            const intersects = raycaster.intersectObjects(intersectableObjects, false);

            let clickedOrnament = null;
            let clickedTreeHitbox = false;

            if (intersects.length > 0) {
                for (const intersect of intersects) {
                    if (ornaments.includes(intersect.object)) {
                        clickedOrnament = intersect.object;
                        break; 
                    }
                    if (intersect.object.userData.isHitbox) {
                        clickedTreeHitbox = true;
                    }
                }
            }
            
            // 1. If an ornament is currently zoomed, any click attempts to zoom out
            if (activeOrnament) {
                toggleOrnamentZoom(activeOrnament, false);
                restoreParticles(); // Ensure particles return to tree form
                return;
            }
            
            // 2. Handle Ornament Click: only zoom in, do not change particle state
            if (clickedOrnament) {
                toggleOrnamentZoom(clickedOrnament, true); 
                return;
            }

            // 3. Handle Tree Hitbox Click: toggle particle state
            if (clickedTreeHitbox) {
                if (isTreeForm) {
                    scatterParticles(); // Tree -> Starlight
                } else {
                    restoreParticles(); // Starlight -> Tree
                }
            } else if (!isTreeForm) {
                // 4. Clicked empty background while scattered: restore particles
                restoreParticles(); 
            }
        }

        // --- Ornament Zoom Animation (Layering Fix Included) ---
        function toggleOrnamentZoom(sprite, shouldZoom) {
            const index = sprite.userData.index;
            const texture = ornamentTextures[index];
            
            const targetWidth = 400; 
            let targetHeight = 400; 

            if (texture && texture.image) {
                const aspectRatio = texture.image.width / texture.image.height;
                targetHeight = targetWidth / aspectRatio; 
            }

            if (shouldZoom && !sprite.userData.isZoomed) {
                // Zoom in
                if (activeOrnament && activeOrnament !== sprite) {
                    toggleOrnamentZoom(activeOrnament, false);
                }

                // *** Layering Fix: Boost render order for zoomed photo ***
                sprite.renderOrder = RENDER_ORDER_ZOOMED; 

                // Detach from treeParticles group and add to scene root
                sprite.updateWorldMatrix(true, false);
                const worldPosition = new THREE.Vector3();
                sprite.getWorldPosition(worldPosition);

                treeParticles.remove(sprite);
                scene.add(sprite);

                sprite.position.copy(worldPosition);

                new TWEEN.Tween(sprite.position)
                    .to({ x: camera.position.x, y: camera.position.y, z: camera.position.z - Z_DISTANCE_FROM_CAMERA }, 800)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                new TWEEN.Tween(sprite.scale)
                    .to({ x: targetWidth, y: targetHeight, z: 1 }, 800)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                sprite.userData.isZoomed = true;
                activeOrnament = sprite;
            } else if (!shouldZoom && sprite.userData.isZoomed) {
                // Zoom out
                
                // *** Layering Fix: Reset render order ***
                sprite.renderOrder = RENDER_ORDER_ORNAMENTS; 

                // Re-add to treeParticles group
                scene.remove(sprite);
                treeParticles.add(sprite);

                new TWEEN.Tween(sprite.position)
                    .to(sprite.userData.originalPos, 600)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .start();
                new TWEEN.Tween(sprite.scale)
                    .to(sprite.userData.originalScale, 600)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .start();
                
                sprite.userData.isZoomed = false;
                activeOrnament = null;
            }
        }
        
        // --- 4. Music Playback Logic ---
        
        function startMusicOnLoad() {
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Playback successful
                }).catch(error => {
                    // Autoplay failed
                    document.getElementById('play-music-btn').textContent = 'ðŸŽ¶ Play Music';
                    audio.pause();
                });
            } else {
                 document.getElementById('play-music-btn').textContent = 'ðŸŽ¶ Play Music';
                 audio.pause();
            }
        }

        document.getElementById('play-music-btn').addEventListener('click', function() {
            if (audio.paused) {
                audio.play().then(() => {
                    this.textContent = 'ðŸ”‡ Mute';
                }).catch(() => {
                    this.textContent = 'âŒ Play failed';
                });
            } else {
                audio.pause();
                this.textContent = 'ðŸŽ¶ Play Music'; 
            }
        });
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start Up ---
        init3D().then(() => {
             animate();
             startMusicOnLoad(); 
        }); 

    </script>
</body>
</html>