<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shannon, Merry Christmas</title> <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Arial', sans-serif;
            cursor: pointer;
        }
        #title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #FFD700;
            font-size: 32px;
            letter-spacing: 5px;
            z-index: 100;
            text-shadow: 0 0 10px #FFD700, 0 0 20px rgba(255, 215, 0, 0.5);
        }
        #loading {
            color: gold; font-size: 20px; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3000;
            background: rgba(0, 0, 0, 0.7); padding: 15px 30px; border-radius: 10px;
        }
        #audio-controls {
            position: absolute;
            bottom: 10px;
            left: 10px; 
            right: auto;
            z-index: 200;
        }
        #play-music-btn {
            padding: 10px; 
            background: #FFD700; 
            border: none; 
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="title">Shannon, Merry Christmas and Happy New Year</div>
    <div id="loading">Loading 3D scene and photos...</div> <div id="audio-controls">
        <button id="play-music-btn">ðŸ”‡ Mute</button> 
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script type="module">
        // --- Core Configuration ---
        let camera, scene, renderer;
        let treeParticles, starSprite, treeHitbox; // Introduced treeHitbox
        let ornaments = []; 
        let activeOrnament = null; 
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(); 
        
        const PARTICLE_COUNT = 8000; 
        const TREE_HEIGHT = 1300;
        const MAX_RADIUS = 480; 
        const ORNAMENT_SIZE = 60;

        let isTreeForm = true; 
        let originalParticlePositions = []; 
        
        // --- Music Control ---
        const audio = new Audio('christmas_music.mp4'); 
        audio.loop = true;

        // --- Asynchronously Load Local Photos (Unchanged) ---
        async function loadAllPhotos() {
            const loadedOrnaments = [];
            const loader = new THREE.TextureLoader();
            
            for (let i = 1; i <= 20; i++) { 
                const path = `photos/${i}.jpg`;
                const h = Math.random() * TREE_HEIGHT * 0.8 + (TREE_HEIGHT * 0.1); 
                const angle = Math.random() * Math.PI * 2;
                const radiusAtHeight = (TREE_HEIGHT - h) / TREE_HEIGHT * MAX_RADIUS;
                const r = radiusAtHeight + 20; 
                const pos = { x: r * Math.cos(angle), y: h - TREE_HEIGHT / 2, z: r * Math.sin(angle) };
                try {
                    const texture = await new Promise((resolve, reject) => {
                        loader.load(path, resolve, undefined, reject);
                    });
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    loadedOrnaments.push({ material, pos });
                } catch (e) {
                    if (i > 1) break; 
                    const material = new THREE.SpriteMaterial({ color: 0x884400 }); 
                    loadedOrnaments.push({ material, pos });
                    break;
                }
            }
            return loadedOrnaments;
        }
        

        // --- 1. Initialize 3D Scene ---
        async function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 1000; 
            camera.position.y = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Particle texture creation
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 215, 0, 0.8)');
            gradient.addColorStop(0.4, 'rgba(128, 100, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,64,64);
            const spriteMap = new THREE.CanvasTexture(canvas);

            // --- Create Particle Tree (Points) ---
            const particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = Math.random() * TREE_HEIGHT;
                const angle = Math.random() * Math.PI * 2;
                const radiusAtHeight = (TREE_HEIGHT - h) / TREE_HEIGHT * MAX_RADIUS;
                const r = radiusAtHeight + (Math.random() - 0.5) * 40; 
                const x = r * Math.cos(angle);
                const y = h - TREE_HEIGHT / 2;
                const z = r * Math.sin(angle);
                positions.push(x, y, z);
                originalParticlePositions.push(new THREE.Vector3(x, y, z)); 
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.1 + 0.05, 0.9, Math.random() * 0.4 + 0.5);
                colors.push(color.r, color.g, color.b);
            }
            
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const particleMaterial = new THREE.PointsMaterial({ size: 12, map: spriteMap, blending: THREE.AdditiveBlending, depthTest: false, transparent: true, vertexColors: true });
            treeParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(treeParticles); 
            
            // --- Fix 1: Create Invisible Click Capture Cone (Hitbox) ---
            const coneGeo = new THREE.ConeGeometry(MAX_RADIUS + 50, TREE_HEIGHT + 100, 32); 
            // Material settings: visible=false, but raycastable
            const coneMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0, 
                visible: false 
            });
            treeHitbox = new THREE.Mesh(coneGeo, coneMat);
            treeHitbox.position.y = 0; // Cone base at y=-TREE_HEIGHT/2, top at y=TREE_HEIGHT/2
            treeHitbox.userData.isHitbox = true; // Mark as hitbox
            scene.add(treeHitbox);
            
            // Star
            const starGeo = new THREE.SphereGeometry(25, 16, 16);
            starSprite = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xFFD700 }));
            starSprite.position.set(0, TREE_HEIGHT / 2 + 30, 0);
            const starGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap, color: 0xFFD700, transparent: true, blending: THREE.AdditiveBlending }));
            starGlow.scale.set(300, 300, 1);
            starSprite.add(starGlow);
            scene.add(starSprite);
            
            // --- Mount Photos (Sprite) ---
            const loadedPhotos = await loadAllPhotos();
            for (const { material, pos } of loadedPhotos) {
                const sprite = new THREE.Sprite(material);
                sprite.position.set(pos.x, pos.y, pos.z);
                sprite.scale.set(ORNAMENT_SIZE, ORNAMENT_SIZE, 1); 
                sprite.userData = { originalPos: sprite.position.clone(), originalScale: sprite.scale.clone(), isZoomed: false };
                treeParticles.add(sprite); 
                ornaments.push(sprite);
            }

            document.getElementById("loading").style.display = "none";
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
        }

        // --- 2. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); 
            
            // Particle tree and Hitbox should rotate together
            if (treeParticles && isTreeForm) {
                treeParticles.rotation.y += 0.002;
                treeHitbox.rotation.y += 0.002; // Hitbox rotates with the tree
            }
            if (starSprite) starSprite.rotation.y += 0.002;

            const time = Date.now() * 0.005;
            if (treeParticles) {
                treeParticles.material.size = 12 + Math.sin(time) * 3;
            }

            renderer.render(scene, camera);
        }
        
        // --- Particle Scatter Function ---
        function scatterParticles() {
            if (!isTreeForm) return;
            isTreeForm = false;
            const positions = treeParticles.geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                const distance = Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                const targetX = distance * Math.sin(phi) * Math.cos(theta);
                const targetY = distance * Math.sin(phi) * Math.sin(theta);
                const targetZ = distance * Math.cos(phi);

                new TWEEN.Tween({ x: positions[i3], y: positions[i3+1], z: positions[i3+2] })
                    .to({ x: targetX, y: targetY, z: targetZ }, 1500)
                    .easing(TWEEN.Easing.Exponential.Out)
                    .onUpdate(function(obj) {
                        positions[i3] = obj.x;
                        positions[i3+1] = obj.y;
                        positions[i3+2] = obj.z;
                        treeParticles.geometry.attributes.position.needsUpdate = true;
                    })
                    .start();
            }
        }

        // --- Particle Restore Function ---
        function restoreParticles() {
            if (isTreeForm) return;
            isTreeForm = true;
            const positions = treeParticles.geometry.attributes.position.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const targetPos = originalParticlePositions[i];
                
                new TWEEN.Tween({ x: positions[i3], y: positions[i3+1], z: positions[i3+2] })
                    .to(targetPos, 1500)
                    .easing(TWEEN.Easing.Exponential.Out)
                    .onUpdate(function(obj) {
                        positions[i3] = obj.x;
                        positions[i3+1] = obj.y;
                        positions[i3+2] = obj.z;
                        treeParticles.geometry.attributes.position.needsUpdate = true;
                    })
                    .start();
            }
        }

        // --- Mouse Click Event (Key Fix) ---
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // Raycast objects: ornaments and the click-capturing Hitbox
            const intersectableObjects = [...ornaments, treeHitbox];
            const intersects = raycaster.intersectObjects(intersectableObjects, false);

            let clickedOrnament = null;
            let clickedTreeHitbox = false;

            if (intersects.length > 0) {
                for (const intersect of intersects) {
                    if (ornaments.includes(intersect.object)) {
                        clickedOrnament = intersect.object;
                        break; 
                    }
                    if (intersect.object.userData.isHitbox) {
                        clickedTreeHitbox = true;
                    }
                }
            }
            
            // --- Logic Flow: Zoomed > Ornament Click > Tree Click > Background Click ---

            // 1. If an ornament is currently zoomed, any click attempts to zoom out
            if (activeOrnament) {
                toggleOrnamentZoom(activeOrnament, false);
                restoreParticles(); 
                return;
            }
            
            // 2. Handle Ornament Click (when no ornament is zoomed)
            if (clickedOrnament) {
                // Clicked a photo: scatter particles first, then zoom in on the photo
                if (isTreeForm) {
                    scatterParticles();
                }
                toggleOrnamentZoom(clickedOrnament, true); 
                return;
            }

            // 3. Core Fix: Handle Tree Click (Ensured stable via Hitbox)
            if (clickedTreeHitbox) {
                // Clicked the empty space of the tree, switch form
                if (isTreeForm) {
                    scatterParticles(); // Scatter
                } else {
                    restoreParticles(); // Restore
                }
            } else if (!isTreeForm) {
                // 4. Clicked completely empty background while scattered
                restoreParticles(); // Restore particles
            }
        }

        // --- Ornament Zoom Animation ---
        function toggleOrnamentZoom(sprite, shouldZoom) {
            if (shouldZoom && !sprite.userData.isZoomed) {
                // Zoom in
                if (activeOrnament && activeOrnament !== sprite) {
                    toggleOrnamentZoom(activeOrnament, false);
                }

                // Remove from treeParticles and add to scene to stop rotation following
                sprite.updateWorldMatrix(true, false);
                const worldPosition = new THREE.Vector3();
                sprite.getWorldPosition(worldPosition);

                treeParticles.remove(sprite);
                scene.add(sprite);

                sprite.position.copy(worldPosition);

                new TWEEN.Tween(sprite.position)
                    .to({ x: camera.position.x, y: camera.position.y, z: camera.position.z - 300 }, 800)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                new TWEEN.Tween(sprite.scale)
                    .to({ x: 400, y: 400, z: 1 }, 800)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                sprite.userData.isZoomed = true;
                activeOrnament = sprite;
            } else if (!shouldZoom && sprite.userData.isZoomed) {
                // Zoom out back to original position
                
                // Re-add photo to treeParticles to resume rotation following
                scene.remove(sprite);
                treeParticles.add(sprite);

                new TWEEN.Tween(sprite.position)
                    .to(sprite.userData.originalPos, 600)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .start();
                new TWEEN.Tween(sprite.scale)
                    .to(sprite.userData.originalScale, 600)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .start();
                
                sprite.userData.isZoomed = false;
                activeOrnament = null;
            }
        }
        
        // --- 4. Music Playback Logic (Autoplay Fix) ---
        
        function startMusicOnLoad() {
            // Fix 2: Attempt autoplay (will likely fail due to browser restrictions)
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Playback successful, button text stays 'ðŸ”‡ Mute'
                }).catch(error => {
                    // Autoplay failed (browser restriction), wait for user interaction
                    document.getElementById('play-music-btn').textContent = 'ðŸŽ¶ Play Music';
                    audio.pause(); // Ensure it is paused
                });
            } else {
                 // Compatibility fallback
                 document.getElementById('play-music-btn').textContent = 'ðŸŽ¶ Play Music';
                 audio.pause();
            }
        }

        document.getElementById('play-music-btn').addEventListener('click', function() {
            if (audio.paused) {
                audio.play().then(() => {
                    this.textContent = 'ðŸ”‡ Mute';
                }).catch(() => {
                    this.textContent = 'âŒ Play failed';
                });
            } else {
                audio.pause();
                this.textContent = 'ðŸŽ¶ Play Music'; 
            }
        });
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start Up ---
        init3D().then(() => {
             animate();
             startMusicOnLoad(); 
        }); 

    </script>
</body>
</html>